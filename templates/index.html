<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Agent Based Traffic Simulation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, "Helvetica Neue", Arial;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: #fff;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        padding: 22px;
        text-align: center;
      }
      h1 {
        font-size: 2.1em;
        margin-bottom: 6px;
      }
      .subtitle {
        opacity: 0.9;
      }

      .controls,
      .lower-controls {
        padding: 14px 18px;
        background: #f8f9fa;
        border-bottom: 2px solid #e9ecef;
      }
      .lower-controls {
        border-top: 2px solid #e9ecef;
        border-bottom: none;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
      }

      button {
        padding: 9px 18px;
        font-size: 15px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: 0.2s;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.18);
      }
      .btn-traffic {
        background: #4caf50;
        color: #fff;
      }
      .btn-traffic:hover {
        background: #45a049;
      }
      .btn-demo {
        background: #2196f3;
        color: #fff;
      }
      .btn-demo:hover {
        background: #0b7dda;
      }
      .btn-start {
        background: #ff9800;
        color: #fff;
      }
      .btn-start:hover {
        background: #e68900;
      }
      .btn-stop {
        background: #f44336;
        color: #fff;
      }
      .btn-stop:hover {
        background: #da190b;
      }
      .btn-reset {
        background: #9e9e9e;
        color: #fff;
      }
      .btn-reset:hover {
        background: #757575;
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .status {
        padding: 12px 18px;
        background: #e9ecef;
        text-align: center;
        font-weight: 600;
        color: #495057;
      }
      .status.active {
        background: #d4edda;
        color: #155724;
      }

      .canvas-shell {
        padding: 20px;
        background: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .viewport {
        position: relative;
        resize: both;
        overflow: hidden;
        border: 3px solid #667eea;
        border-radius: 10px;
        background: #000;
        min-width: 300px;
        min-height: 200px;
        width: 800px;
        height: 600px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        cursor: grab;
      }
      .viewport.panning {
        cursor: grabbing;
      }
      .viewport > canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
      }

      .spacer {
        flex: 1 1 auto;
        min-width: 8px;
      }
      .zoom-wrap {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        border: 1px solid #e1e5ea;
        border-radius: 8px;
        background: #fff;
      }
      input[type="range"] {
        width: 180px;
      }

      .info {
        padding: 14px 18px;
        background: #f8f9fa;
        text-align: center;
        font-size: 16px;
        color: #495057;
      }
      .kbd {
        background: #f3f4f6;
        border: 1px solid #e5e7eb;
        border-bottom-width: 2px;
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        font-family: ui-monospace, Menlo, Consolas, monospace;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ðŸš— Agent Based Traffic Simulation</h1>
        <p class="subtitle">Resize, zoom, and pan</p>
      </header>

      <div class="controls">
        <div class="row">
          <button class="btn-traffic" onclick="initSimulation('traffic')">
            Initialize Traffic
          </button>
          <button class="btn-demo" onclick="initSimulation('demo')">
            Initialize Demo
          </button>
          <button
            class="btn-start"
            id="startBtn"
            onclick="startSimulation()"
            disabled
          >
            Start
          </button>
          <button
            class="btn-stop"
            id="stopBtn"
            onclick="stopSimulation()"
            disabled
          >
            Stop
          </button>
          <button class="btn-reset" onclick="resetSimulation()">Reset</button>

          <div class="spacer"></div>

          <div class="zoom-wrap">
            <button id="zoomOutBtn" title="Zoom Out">âˆ’</button>
            <input
              id="zoomSlider"
              type="range"
              min="0.25"
              max="4"
              step="0.05"
              value="1"
            />
            <button id="zoomInBtn" title="Zoom In">+</button>
            <span id="zoomLabel">100%</span>
            <button id="resetViewBtn" title="Reset view">Reset View</button>
          </div>

          <div class="zoom-wrap">
            <label
              >Default width (px):
              <input
                id="vwInput"
                type="number"
                min="300"
                value="800"
                style="width: 90px"
            /></label>
            <label
              >Default height (px):
              <input
                id="vhInput"
                type="number"
                min="200"
                value="600"
                style="width: 90px"
            /></label>
            <button id="applyViewport">Apply Size</button>
            <button id="toggleSense">Sensing: On</button>
          </div>
        </div>
      </div>

      <div class="status" id="status">
        No simulation loaded. Click a button above to initialize.
      </div>

      <div class="canvas-shell">
        <div class="viewport" id="viewport">
          <canvas id="simulationCanvas"></canvas>
        </div>
      </div>

      <div class="lower-controls">
        <div class="row" style="font-size: 13px; color: #666">
          Tips: drag to pan. Scroll to zoom at cursor. Keys:
          <span class="kbd">+</span>, <span class="kbd">âˆ’</span>,
          <span class="kbd">0</span>.
        </div>
      </div>

      <div class="info">
        Step: <span id="stepCount">0</span> | Agents:
        <span id="agentCount">0</span>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("simulationCanvas");
      const ctx = canvas.getContext("2d");
      const statusDiv = document.getElementById("status");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const stepCountSpan = document.getElementById("stepCount");
      const agentCountSpan = document.getElementById("agentCount");
      const viewport = document.getElementById("viewport");
      const vwInput = document.getElementById("vwInput");
      const vhInput = document.getElementById("vhInput");
      const applyViewportBtn = document.getElementById("applyViewport");
      const toggleSenseBtn = document.getElementById("toggleSense");

      const zoomSlider = document.getElementById("zoomSlider");
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomLabel = document.getElementById("zoomLabel");
      const resetViewBtn = document.getElementById("resetViewBtn");

      const driveStrategyColorMap = {
        hard_brake: "#ef4444",
        brake: "#f77926",
        accelerate: "#22c55e",
        cruise: "#eab308",
      };

      let isRunning = false,
        intervalId = null,
        simType = null;

      // World extents (mm) from backend
      let maxX = 1000,
        maxY = 1000;
      // Highway info
      let laneCount = 0,
        laneWidth = 0;

      // View transform
      let fitScale = 1,
        zoom = 1,
        s = 1,
        ox = 0,
        oy = 0;

      // Panning
      let isPanning = false,
        panStartX = 0,
        panStartY = 0,
        oxAtPan = 0,
        oyAtPan = 0;

      let showSensing = true;
      let lastAgents = [];
      let laneCenters = [];

      function setStatus(msg, active = false) {
        statusDiv.textContent = msg;
        statusDiv.className = active ? "status active" : "status";
      }
      toggleSenseBtn.addEventListener("click", () => {
        showSensing = !showSensing;
        toggleSenseBtn.textContent = showSensing
          ? "Sensing: On"
          : "Sensing: Off";
        redraw();
      });

      // Resize and HiDPI
      const ro = new ResizeObserver(() => layoutPreserveCenter());
      ro.observe(viewport);

      function layoutPreserveCenter() {
        const cssW = viewport.clientWidth,
          cssH = viewport.clientHeight;
        const centerBefore = screenToWorld(cssW / 2, cssH / 2);

        const dpr = window.devicePixelRatio || 1;
        canvas.style.width = `${cssW}px`;
        canvas.style.height = `${cssH}px`;
        canvas.width = Math.max(1, Math.round(cssW * dpr));
        canvas.height = Math.max(1, Math.round(cssH * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        fitScale = Math.min(cssW / maxX, cssH / maxY);
        s = fitScale * zoom;

        const [wx, wy] = centerBefore;
        ox = cssW / 2 - wx * s;
        oy = cssH / 2 - (maxY - wy) * s;

        redraw();
      }

      function screenToWorld(px, py) {
        return [(px - ox) / s, maxY - (py - oy) / s];
      }
      function worldToScreen(x, y) {
        return [ox + x * s, oy + (maxY - y) * s];
      }

      // Zoom
      function setZoom(newZoom, ax = null, ay = null) {
        newZoom = Math.min(4, Math.max(0.25, newZoom));
        if (newZoom === zoom) return;
        const cssW = viewport.clientWidth,
          cssH = viewport.clientHeight;
        const px = ax ?? cssW / 2,
          py = ay ?? cssH / 2;
        const [wx, wy] = screenToWorld(px, py);
        zoom = newZoom;
        s = fitScale * zoom;
        ox = px - wx * s;
        oy = py - (maxY - wy) * s;
        zoomSlider.value = String(zoom);
        zoomLabel.textContent = `${Math.round(zoom * 100)}%`;
        redraw();
      }
      zoomSlider.addEventListener("input", (e) =>
        setZoom(parseFloat(e.target.value))
      );
      zoomInBtn.addEventListener("click", () => setZoom(zoom * 1.1));
      zoomOutBtn.addEventListener("click", () => setZoom(zoom / 1.1));
      resetViewBtn.addEventListener("click", resetView);

      viewport.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const r = viewport.getBoundingClientRect();
          const factor = e.deltaY > 0 ? 1 / 1.08 : 1.08;
          setZoom(zoom * factor, e.clientX - r.left, e.clientY - r.top);
        },
        { passive: false }
      );

      window.addEventListener("keydown", (e) => {
        if (e.key === "+" || e.key === "=") setZoom(zoom * 1.1);
        else if (e.key === "-" || e.key === "_") setZoom(zoom / 1.1);
        else if (e.key === "0") resetView();
      });

      function resetView() {
        zoom = 1;
        zoomSlider.value = "1";
        zoomLabel.textContent = "100%";
        const cssW = viewport.clientWidth,
          cssH = viewport.clientHeight;
        fitScale = Math.min(cssW / maxX, cssH / maxY);
        s = fitScale * zoom;
        const contentW = s * maxX,
          contentH = s * maxY;
        ox = (cssW - contentW) / 2;
        oy = (cssH - contentH) / 2;
        redraw();
      }

      // Panning
      viewport.addEventListener("mousedown", (e) => {
        isPanning = true;
        viewport.classList.add("panning");
        panStartX = e.clientX;
        panStartY = e.clientY;
        oxAtPan = ox;
        oyAtPan = oy;
      });
      window.addEventListener("mousemove", (e) => {
        if (!isPanning) return;
        ox = oxAtPan + (e.clientX - panStartX);
        oy = oyAtPan + (e.clientY - panStartY);
        redraw();
      });
      window.addEventListener("mouseup", () => {
        isPanning = false;
        viewport.classList.remove("panning");
      });

      // Default viewport size
      applyViewportBtn.addEventListener("click", () => {
        const w = Math.max(300, parseInt(vwInput.value || "800", 10));
        const h = Math.max(200, parseInt(vhInput.value || "600", 10));
        viewport.style.width = `${w}px`;
        viewport.style.height = `${h}px`;
      });

      // Backend plumbing
      async function initSimulation(type) {
        try {
          const res = await fetch(`/api/init/${type}`);
          const data = await res.json();
          if (data.status === "success") {
            simType = type;
            maxX = data.x_max;
            maxY = data.y_max;
            laneCount = data.lane_count ?? 0;
            laneWidth = data.lane_width ?? 0;
            resetView();
            setStatus(`${data.message}. Click Start to begin.`, true);
            startBtn.disabled = false;
            stopBtn.disabled = true;
            lastAgents = [];
            laneCount = data.lane_count ?? 0;
            laneWidth = data.lane_width ?? 0;
            laneCenters = Array.isArray(data.lane_centers)
              ? data.lane_centers.slice().sort((a, b) => a - b)
              : [];
            redraw();
          } else setStatus(`Error: ${data.message}`);
        } catch (err) {
          setStatus(`Error: ${err.message}`);
        }
      }

      let pollingMs = 50;
      function startSimulation() {
        if (isRunning) return;
        isRunning = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        setStatus("Simulation running...", true);
        intervalId = setInterval(stepSimulation, pollingMs);
      }
      function stopSimulation() {
        if (!isRunning) return;
        isRunning = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Simulation paused");
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }
      async function resetSimulation() {
        stopSimulation();
        try {
          const res = await fetch("/api/reset");
          const data = await res.json();
          if (data.status === "success") {
            simType = null;
            lastAgents = [];
            startBtn.disabled = true;
            stopBtn.disabled = true;
            stepCountSpan.textContent = "0";
            agentCountSpan.textContent = "0";
            resetView();
            setStatus("Simulation reset. Initialize a new simulation.");
          }
        } catch (err) {
          setStatus(`Error: ${err.message}`);
        }
      }
      async function stepSimulation() {
        try {
          const res = await fetch("/api/step");
          const data = await res.json();
          if (data.status === "success") {
            lastAgents = data.agents;
            redraw();
            stepCountSpan.textContent = data.step;
            agentCountSpan.textContent = data.agents.length;
          } else {
            setStatus(`Error: ${data.message}`);
            stopSimulation();
          }
        } catch (err) {
          setStatus(`Error: ${err.message}`);
          stopSimulation();
        }
      }

      // Drawing
      function clearCanvas() {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      }

      // Clip slightly inside the highway to avoid edge shaving
      function beginHighwayClip() {
        const eps = 0.5 / s; // 0.5 CSS px in world units
        const [x0, y0] = worldToScreen(0 + eps, maxY - eps); // top-left
        const [x1, y1] = worldToScreen(maxX - eps, 0 + eps); // bottom-right
        ctx.beginPath();
        ctx.rect(x0, y0, x1 - x0, y1 - y0);
        ctx.clip();
        return { x0, y0, x1, y1, w: x1 - x0, h: y1 - y0 };
      }
      // SCREEN rect for the highway [0..maxX] Ã— [0..maxY], inclusive of edges.
      // Uses floor for the min edge and ceil for the max edge so we never "shave" a column.
      function getHighwayRect() {
        const pTL = worldToScreen(0, maxY); // top-left in world
        const pBR = worldToScreen(maxX, 0); // bottom-right in world

        const xMin = Math.min(pTL[0], pBR[0]);
        const xMax = Math.max(pTL[0], pBR[0]);
        const yMin = Math.min(pTL[1], pBR[1]);
        const yMax = Math.max(pTL[1], pBR[1]);

        const x0 = Math.floor(xMin);
        const y0 = Math.floor(yMin);
        const x1 = Math.ceil(xMax);
        const y1 = Math.ceil(yMax);

        return { x0, y0, w: x1 - x0, h: y1 - y0, x1, y1 };
      }

      function drawHighway() {
        const R = getHighwayRect();

        // Base asphalt exactly fills highway rect (no clip)
        ctx.fillStyle = "#222";
        ctx.fillRect(R.x0, R.y0, R.w, R.h);

        if (!laneWidth || !laneCenters || laneCenters.length === 0) {
          drawHighwayBorders();
          return;
        }

        // --- Build WORLD X edges from real lane centers ---
        // A lane i spans [c - w/2, c + w/2]. Internal "lane edges" are the boundaries between lanes.
        const half = laneWidth / 2;
        const centers = laneCenters.slice().sort((a, b) => a - b);

        // Lane edges (world): start with 0, then every lane left/right, and end with maxX
        const worldEdges = [0];
        for (const c of centers) {
          worldEdges.push(Math.max(0, c - half));
          worldEdges.push(Math.min(maxX, c + half));
        }
        if (worldEdges[worldEdges.length - 1] < maxX) worldEdges.push(maxX);

        // Map once to SCREEN X, pin ends to highway rect, round internals
        let screenEdges = worldEdges.map((x) => worldToScreen(x, 0)[0]);
        screenEdges[0] = R.x0;
        screenEdges[screenEdges.length - 1] = R.x1;
        for (let i = 1; i < screenEdges.length - 1; i++)
          screenEdges[i] = Math.round(screenEdges[i]);

        // --- Paint consecutive strips full height; accumulated to avoid any gap at right ---
        let x = screenEdges[0];
        for (let i = 0; i < screenEdges.length - 1; i++) {
          const next = i < screenEdges.length - 2 ? screenEdges[i + 1] : R.x1; // force last to hit R.x1
          const w = next - x;
          if (w <= 0) {
            x = next;
            continue;
          }

          // Decide if this strip is a lane or shoulder by sampling midpoint in WORLD
          const midW = (worldEdges[i] + worldEdges[i + 1]) / 2;
          let isLane = false;
          for (const c of centers) {
            if (midW >= c - half && midW <= c + half) {
              isLane = true;
              break;
            }
          }

          ctx.fillStyle = isLane ? (i % 2 ? "#343434" : "#2c2c2c") : "#151515";
          ctx.fillRect(x, R.y0, w, R.h);

          x = next;
        }

        // --- Dashed lines at LANE EDGES (boundaries between lanes), not lane centers ---
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.80)";
        ctx.setLineDash([12 * s, 14 * s]);
        ctx.lineWidth = Math.max(1, 2 * (s / (fitScale || 1)));

        // Collect unique internal edges (exclude 0 and maxX)
        const edgeSet = new Set();
        for (const c of centers) {
          const L = Math.max(0, c - half);
          const Rw = Math.min(maxX, c + half);
          edgeSet.add(L);
          edgeSet.add(Rw);
        }
        edgeSet.delete(0);
        edgeSet.delete(maxX);

        for (const edge of Array.from(edgeSet).sort((a, b) => a - b)) {
          const [sx0, sy0] = worldToScreen(edge, 0);
          const [sx1, sy1] = worldToScreen(edge, maxY);
          ctx.beginPath();
          ctx.moveTo(sx0, sy0);
          ctx.lineTo(sx1, sy1);
          ctx.stroke();
        }
        ctx.restore();

        drawHighwayBorders();
      }
      // Paint black outside the highway instead of clipping (avoids edge shaving entirely)
      function maskOutsideHighway() {
        const R = getHighwayRect();
        const W = canvas.width / (window.devicePixelRatio || 1);
        const H = canvas.height / (window.devicePixelRatio || 1);

        ctx.fillStyle = "#000";
        // left
        if (R.x0 > 0) ctx.fillRect(0, 0, R.x0, H);
        // right
        if (R.x1 < W) ctx.fillRect(R.x1, 0, W - R.x1, H);
        // top
        if (R.y0 > 0) ctx.fillRect(R.x0, 0, R.w, R.y0);
        // bottom
        if (R.y1 < H) ctx.fillRect(R.x0, R.y1, R.w, H - R.y1);
      }

      function drawHighwayBorders() {
        ctx.save();
        ctx.strokeStyle = "#f5f5f5";
        ctx.lineWidth = Math.max(2, 3 * (s / (fitScale || 1)));
        const tL = worldToScreen(0, maxY),
          tR = worldToScreen(maxX, maxY);
        const bL = worldToScreen(0, 0),
          bR = worldToScreen(maxX, 0);
        ctx.beginPath();
        ctx.moveTo(tL[0], tL[1]);
        ctx.lineTo(tR[0], tR[1]);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bL[0], bL[1]);
        ctx.lineTo(bR[0], bR[1]);
        ctx.stroke();
        ctx.restore();
      }

      function drawAgents() {
        for (const a of lastAgents) {
          const [px, py] = worldToScreen(a.x, a.y);
          const halfL = Math.max(0.5, (a.length * s - 1) / 2);
          const halfW = (a.width * s) / 2;

          if (showSensing && Number.isFinite(a.sensing_distance)) {
            const r = a.sensing_distance * s;
            ctx.save();
            ctx.beginPath();
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(33,150,243,0.12)";
            ctx.strokeStyle = "rgba(33,150,243,0.35)";
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          }

          const color =
            {
              hard_brake: "#ef4444",
              brake: "#f77926",
              accelerate: "#22c55e",
              cruise: "#eab308",
            }[a.drive_strategy] || "#ffffff";
          ctx.save();
          ctx.translate(px, py);
          const heading = simType === "traffic" ? -a.heading : a.heading;
          ctx.rotate(heading);
          ctx.fillStyle = color;
          ctx.strokeStyle = "#111";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.rect(-halfL, -halfW, 2 * halfL, 2 * halfW);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(halfL, -halfW);
          ctx.lineTo(halfL, halfW);
          ctx.stroke();
          ctx.restore();
        }
      }

      function redraw() {
        clearCanvas();
        drawHighway();
        drawAgents(); // draw without clip
        maskOutsideHighway(); // cover overflow outside highway
      }

      // --- NEW: highway rect in SCREEN pixels (sorted, integer-snapped) ---
      // SCREEN rect for the highway [0..maxX] Ã— [0..maxY]
      // Highway rect in SCREEN pixels (inclusive of edges)
      function getHighwayRect() {
        const pTL = worldToScreen(0, maxY); // top-left
        const pBR = worldToScreen(maxX, 0); // bottom-right

        const x0 = Math.floor(Math.min(pTL[0], pBR[0]));
        const y0 = Math.floor(Math.min(pTL[1], pBR[1]));
        const x1 = Math.ceil(Math.max(pTL[0], pBR[0]));
        const y1 = Math.ceil(Math.max(pTL[1], pBR[1]));

        return { x0, y0, x1, y1, w: x1 - x0, h: y1 - y0 };
      }

      // --- NEW: fillRect with integer snapping to reduce AA seams ---
      function fillRectSnap(x, y, w, h, color) {
        ctx.fillStyle = color;
        const rx = Math.round(x);
        const ry = Math.round(y);
        const rw = Math.round(x + w) - rx;
        const rh = Math.round(y + h) - ry;
        if (rw > 0 && rh > 0) ctx.fillRect(rx, ry, rw, rh);
      }
      function debugOutline() {
        const R = getHighwayRect();
        ctx.save();
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(R.x0 + 0.5, R.y0 + 0.5, R.w - 1, R.h - 1);
        ctx.restore();
      }
      // call: debugOutline();

      // Initial layout
      layoutPreserveCenter();
    </script>
  </body>
</html>
